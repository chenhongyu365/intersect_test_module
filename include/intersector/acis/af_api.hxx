/*******************************************************************/
/*    Copyright (c) 1989-2020 by Spatial Corp.                     */
/*    All rights reserved.                                         */
/*    Protected by U.S. Patents 5,257,205; 5,351,196; 6,369,815;   */
/*                              5,982,378; 6,462,738; 6,941,251    */
/*    Protected by European Patents 0503642; 69220263.3            */
/*    Protected by Hong Kong Patent 1008101A                       */
/*******************************************************************/
// C++ header file for facet library users.
/*******************************************************************/
#ifndef FACETER_API_HEADER
#define FACETER_API_HEADER
#include <math.h>
#include <stdio.h>
#include "dcl_fct.h"
#include "api.hxx"
#include "logical.h"
#include "entity.hxx"
#include "lists.hxx"
#include "attrib.hxx"
#include "box.hxx"
#include "af_enum.hxx"
#include "refine.hxx"
#include "mesh.hxx"
#include "meshmg.hxx"
#include "atteye3d.hxx"
#include "nodedata.hxx"
#include "vtplate.hxx"
#include "rvattr.hxx"
#include "meshat.hxx"
#include "fctdattr.hxx"
#include "ppm.hxx"
#include "ppmeshmg.hxx"
#include "ppmface.hxx"
#include "idx_mm.hxx"
#include "idx_mesh.hxx"
class outcome;
class BODY;
class LUMP;
class SHELL;
class FACE;
class AF_POINT;
class facet_options;

/**
 * @file af_api.hxx
 * @CAA2Level L1
 * @CAA2Usage U1
 * \defgroup FCTAPI Faceting
 *
 * \ingroup VISMODULE
 * @{
 */
/**
* Initializes the faceter library.
* <br><br>
* <b>Role:</b> This API initializes the faceter with some default refinements
* that produces only triangles and quadrilaterals. A mesh manager
* is required to direct the facet data generated by the faceter.
* <br><br>
* <b>Effect:</b> System routine
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
* <br><br>
**/
DECL_FCT outcome api_initialize_faceter();


/**
* Terminates the faceter library.
* <br><br>
* <b>Role:</b> This API terminates the faceter and free its internal data.
* Further calls made to the faceter may cause unpredictable problems.
* <br><br>
* <b>Effect:</b> System Routine
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
* <br><br>
**/
DECL_FCT outcome api_terminate_faceter();


//					MESH MANAGER
//
// The mesh manager determines how and to where the facet data will be output.

/**
* Sets the current mesh manager of faceter.
* <br><br>
* <b>Role:</b> Set the current mesh manager in the faceter. A mesh manager is
* required to direct the facet data generated in the faceter. If it is set to <tt>NULL</tt>,
* no output will be provided. For additional information on mesh managers refer to 
* the Technical Article <i>Mesh Managers</i>.
* <br><br>
* <b>Errors:</b> Pointer to mesh manager, if non-<tt>NULL</tt>, must be a <tt>MESH_MANAGER</tt> 
* or a class derived from <tt>MESH_MANAGER</tt>.
* <br><br>
* <b>Effect:</b> Changes mesh manager used for faceting.
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
* <br><br>
* @param mm
* mesh manager to set.
* @param ao
* acis options.
**/
DECL_FCT outcome api_set_mesh_manager(
		MESH_MANAGER *mm,						// mesh manager to use
		AcisOptions* ao = NULL
		);

/**
* Gets the current mesh manager of faceter.
* <br><br>
* <b>Role:</b> Returns the current mesh manager of the faceter. If the mesh manager has been set 
* to <tt>NULL</tt>, a <tt>NULL</tt> value will be returned.
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
* <br><br>
* @param mm
* current mesh returned.
* @param ao
* acis options.
**/
DECL_FCT outcome api_get_mesh_manager(
		MESH_MANAGER *& mm,						// active manager
		AcisOptions* ao = NULL
		);


//					REFINEMENTS
//
// A refinement controls how and how accurate the facets approximate the solid
// model.  A refinement attached to a face applied to that face.  A refinement
// attached to a shell, a lump, or a body may apply to the contained faces.
// Based on the surface type of a face, the refinement is first searched from
// the face, then the shell, then the lump, then the body, then finally from
// the defaults of the faceter.
// Setting a NULL refinement is equivalent to clearing a refinement, whereas
// a NULL refinement returned indicates there is no attached refinement of
// the requested surface type.

/**
* Creates a refinement.
* <br><br>
* <b>Role:</b> This API creates a new refinement. The <tt>REFINEMENT</tt> is initialized
* with the default values. The use count of the returned refinement is also incremented.
* Functions calling this API function will typically need to call the <tt>remove</tt> method of the
* returned refinement to decrement its use count when it is no longer needed by the calling function.
* <br><br>
* <b>Effect:</b> Changes model
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
* <br><br>
* @param ref
* new refinement.
* @param ao
* acis options.
**/
DECL_FCT outcome api_create_refinement(
		REFINEMENT *&ref,						// new refinement created
		AcisOptions* ao = NULL
	);

/**
* Attaches a <tt>REFINEMENT</tt> to an entity (<tt>BODY</tt>, <tt>LUMP</tt>, <tt>SHELL</tt>, <tt>FACE</tt>), 
* and optionally its lower topology.
* <br><br>
* <b>Role:</b> This API attaches a <tt>REFINEMENT</tt> to an <tt>ENTITY</tt> and (if
* <tt>apply_to_descend</tt> is <tt>TRUE</tt>) all of its descendents (possibly lumps, shells, and
* faces). If the <tt>REFINEMENT</tt> is <tt>NULL</tt>, all the <tt>REFINEMENT</tt>s are removed from the
* entity and (if <tt>apply_to_descend</tt> is <tt>TRUE</tt>) all of its descendents.
* <br><br>
* The use count of the given refinement is incremented when it is attached to an entity. If another
* refinement of the same %surface type is attached to an entity, its use count will be decremented
* when it is detached.
* <br><br>
* <b>Errors:</b> Pointer to given entity must be non-<tt>NULL</tt> and to a <tt>BODY</tt>, 
* <tt>LUMP</tt>, <tt>SHELL</tt>, or <tt>FACE</tt>. Pointer to given refinement, if non-<tt>NULL</tt>, 
* must be a <tt>REFINEMENT</tt>.
* <br><br>
* <b>Effect:</b> Changes model
* <br><br>
* <b>Journal: </b> Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
* <br><br>
* @param ent
* entity to attach refinement.
* @param ref
* refinement to attach.
* @param apply_to_descendents
* attach the refinement additionally to the entity's descendents?
* @param ao
* acis options.
**/
DECL_FCT outcome api_set_entity_refinement(
		ENTITY     *ent,						// entity to which to attach
		REFINEMENT *ref = (REFINEMENT *)NULL,	// refinement to use
		logical    apply_to_descendents = FALSE,	// also attach to lower level
		AcisOptions* ao = NULL
	);

/**
* Gets the refinement of the given %surface type attached to the given entity.
* <br><br>
* <b>Role:</b> If no refinement with the given %surface type is found, a <tt>NULL</tt> value is returned.
* The %surface type may be one of:
* <br><br>
* <table width="60%">
* <tr><td>  <tt>AF_SURF_ALL </tt></td>                 <td>  = all surfaces</td></tr>
* <tr><td>  <tt>AF_SURF_REGULAR</tt></td>              <td>  = plane, cone, sphere, torus</td></tr>
* <tr><td>  <tt>AF_SURF_IRREGULAR</tt></td>            <td>  = spline</td></tr>
* <tr><td>  <tt>AF_SURF_PLANE</tt></td>                <td>  = plane</td></tr>
* <tr><td>  <tt>AF_SURF_CONE</tt></td>                 <td>  = cone</td></tr>
* <tr><td>  <tt>AF_SURF_SPHERE</tt></td>               <td>  = sphere</td></tr>
* <tr><td>  <tt>AF_SURF_TORUS</tt></td>                <td>  = torus</td></tr>
* <tr><td>  <tt>AF_SURF_SPLINE</tt></td>               <td>  = spline</td></tr>
* </table>
* <br>
* If %surface type is not specified, it is set to <tt>AF_SURF_ALL</tt>.
* <br><br>
* The use count of the returned refinement is incremented. Functions calling this API function 
* will typically need to call the <tt>remove</tt> method of the returned refinement to decrement its use count
* when it is no longer needed by the calling function.
* <br><br>
* <b>Errors:</b> Pointer to given entity must be non-<tt>NULL</tt> and to a <tt>BODY</tt>, 
* <tt>LUMP</tt>, <tt>SHELL</tt>, or <tt>FACE</tt>.
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
* <br><br>
* @param entity
* entity to examine.
* @param ref
* refinement returned.
* @param surftype
* %surface type of refinement (optional).
* @param ao
* acis options.
**/
DECL_FCT outcome api_get_entity_refinement(
		ENTITY * entity,						// entity to which to attach
		REFINEMENT *&ref,						// refinement attached
		AF_SURF_MODE surftype = AF_SURF_ALL,	// surface type of refinement
		AcisOptions* ao = NULL
	);

/**
* Sets the default <tt>REFINEMENT</tt> in the faceter.
* <br><br>
* <b>Role:</b> If the refinement is <tt>NULL</tt>, it will default to the default refinement
* created by <tt>api_initialise_faceter</tt>.
* <br><br>
* When you create a refinement and pass it to <tt>api_set_default_refinement</tt>, ACIS takes 
* ownership of that refinement object, including responsibility for its deletion.
* More specifically, the use count of the given refinement is incremented. If another
* default refinement has the same %surface type, its use count will be decremented.
* <br><br>
* <b>Errors:</b> Pointer to given refinement, if non-<tt>NULL</tt>, must be a <tt>REFINEMENT</tt>.
* <br><br>
* <b>Effect:</b> Changes model
* <br><br>
* <b>Journal: </b> Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
* <br><br>
* @param ref
* default refinement to set.
* @param ao
* acis options.
**/
DECL_FCT outcome api_set_default_refinement(
		REFINEMENT *ref,						// default refinement to use
		AcisOptions* ao = NULL
	);

/**
* Gets the default <tt>REFINEMENT</tt> associated with a type of surface.
* <br><br>
* <b>Role:</b> A <tt>REFINEMENT</tt> is always returned. If a <tt>REFINEMENT</tt> specific to the
* %surface type is not available, one that is associated with a more general type
* is returned. The %surface type may be one of:
* <br><br>
* <table width="60%">
* <tr><td><tt>AF_SURF_ALL</tt></td>                   <td>= all surfaces</td></tr>
* <tr><td><tt>AF_SURF_REGULAR</tt></td>               <td>= plane, cone, sphere, torus</td></tr>
* <tr><td><tt>AF_SURF_IRREGULAR</tt></td>             <td>= spline</td></tr>
* <tr><td><tt>AF_SURF_PLANE</tt></td>                 <td>= plane</td></tr>
* <tr><td><tt>AF_SURF_CONE</tt></td>                  <td>= cone</td></tr>
* <tr><td><tt>AF_SURF_SPHERE</tt></td>                <td>= sphere</td></tr>
* <tr><td><tt>AF_SURF_TORUS</tt></td>                 <td>= torus</td></tr>
* <tr><td><tt>AF_SURF_SPLINE</tt></td>                <td>= spline</td></tr>
* </table>
* <br>
* If the %surface type is not specified, it is set to <tt>AF_SURF_ALL</tt>.
* <br><br>
* The use count of the returned refinement is incremented. Functions calling this API function 
* will typically need to call the <tt>remove</tt> method of the returned refinement to decrement its use count
* when it is no longer needed by the calling function.
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
* <br><br>
* @param ref
* default refinement.
* @param surftype
* %surface type of refinement (optional).
* @param ao
* acis options.
**/
DECL_FCT outcome api_get_default_refinement(
		REFINEMENT   *&ref,						// active default refinement
		AF_SURF_MODE surftype = AF_SURF_ALL,	// associated surface type
		AcisOptions* ao = NULL
		);


/**
* Creates facets for an entity.
* <br><br>
* <b>Role:</b> This API function facets the given entity (and sub-entities). The behavior of the Faceter may be 
* specified by the <tt>facet_options</tt> object. The default behavior, if a <tt>facet_options</tt> object 
* is not specified, is to use a Visualization Facet Options object. For more information on using 
* <tt>facet_options</tt> objects, refer to the Technical Article on <i>Facet Options</i>. Alternatively, the 
* behavior of the Faceter may be specified using <tt>REFINEMENT</tt> objects. For more information on 
* using refinements, refer to the Technical Article on <i>Refinements</i>.   
* <br><br>
* The facets are passed on to the current <tt>MESH_MANAGER</tt>, which appropriately directs
* the data. For example, it may display the facets, output them to a file, or attach them to a face.
* For more information on mesh managers, refer to the Technical Article on <i>Mesh Managers</i>.
* <br><br>
* <b>Errors:</b> Pointer to given entity must be non-<tt>NULL</tt> and to a <tt>BODY</tt>, 
* <tt>LUMP</tt>, <tt>SHELL</tt>, or <tt>FACE</tt>.
* <br><br>
* <b>Effect:</b> Changes model
* <br><br>
* <b>Journal: </b> Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler, 3D ACIS Polyhedral
* <br><br>
* @param entity
* entity to facet.
* @param fo
* instance of a <tt>facet_options</tt> object, specifying how to facet the entities.
* @param ao
* acis options.
* @see api_facet_entity, api_facet_entities
**/
DECL_FCT outcome api_facet_entity(
		ENTITY		*entity,					// entity to facet
		facet_options*	fo = NULL,
		AcisOptions* ao = NULL
	);

/**
* Creates facets for a list of entities.
* <br><br>
* <b>Role:</b> This API function provides a way to facet more than one entity
* at a time. Note: all entities in the given entity list must be owned by the 
* given owner. 
* <br><br>
* The typical use of this function is to incrementally facet the faces of a body, when a list
* of modified or new faces are passed to be faceted. For more information on incremental faceting, 
* refer to the Technical Article on <i>Incremental Faceting</i>.
* <br><br> 
* The behavior of the Faceter is specified by the <tt>facet_options</tt> object. The default behavior, 
* if a <tt>facet_options</tt> object is not specified, is to use a Visualization Facet Options object. 
* For more information on using <tt>facet_options</tt> objects, refer to the Technical Article on
* <i>Facet Options</i>.
* <br><br>
* The facets are passed on to the current <tt>MESH_MANAGER</tt>, which appropriately directs
* the data. For example, it may display the facets, output them to a file, or attach them to a face.
* For more information on mesh managers, refer to the Technical Article on <i>Mesh Managers</i>.
* <br><br>
* <b>Errors:</b> Owner entity must be non-<tt>NULL</tt> and to a <tt>BODY</tt>, <tt>LUMP</tt>
* or <tt>SHELL</tt>. entity_list must be non-<tt>NULL</tt> and non-empty. All entity pointers
* in entity_list must be non-<tt>NULL</tt> and to a <tt>BODY</tt>, <tt>LUMP</tt>, <tt>SHELL</tt>,
* or <tt>FACE</tt>.
* <br><br>
* <b>Effect:</b> Changes model
* <br><br>
* <b>Journal: </b> Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler, 3D ACIS Polyhedral
* <br><br>
* @param owner
* owning entity.
* @param entity_list
* entities to facet.
* @param fo
* instance of a <tt>facet_options</tt> object, specifying how to facet the entities.
* @param ao
* acis options.
* @see api_facet_entity, api_facet_entities
**/
DECL_FCT outcome api_facet_entities (
		ENTITY      *owner,						// owner of entities in list
		ENTITY_LIST *entity_list,			// list of entities
		facet_options*	fo = NULL,
		AcisOptions*	ao = NULL
	);

/**
* Facets a list of bodies.
* <b>Role:</b> Facets multiple bodies in multiple threads to speed the operation,
* if the <tt>option_header</tt> <tt>faceter_allow_multithreading</tt> is true
* <br><br>
* <b>Errors:</b> Owner entity must be non-<tt>NULL</tt> and to a <tt>BODY</tt>.
* The entity_list must be non-<tt>NULL</tt> and non-empty.
* All entity pointers in entity_list must be non-<tt>NULL</tt> and to a <tt>BODY</tt>
* <br><br>
* <b>Effect:</b> Changes model
* <br><br>
* <b>Journal: </b> Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler, 3D ACIS Polyhedral
* <br><br>
* @param bodies
* Each body in this list is required to be a top level entity: i.e., it is required to be its own owner.
* @param fo
* <tt>facet_options</tt> object controlling faceting algorithm.
* @param ao
* <tt>AcisOptions</tt> object controlling journalling etc.
**/
DECL_FCT outcome api_facet_bodies(ENTITY_LIST const& bodies, facet_options* fo = NULL, AcisOptions* ao = NULL);

/**
* Deletes facets.
* <br><br>
* <b>Role:</b> Deletes the facets attached to the given entity and optionally to it's descendents.
* <br><br>
* <b>Errors:</b> Pointer to given entity must be non-<tt>NULL</tt> and to a <tt>BODY</tt>, 
* <tt>LUMP</tt>, <tt>SHELL</tt>, or <tt>FACE</tt>.
* <br><br>
* <b>Effect:</b> Changes model
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler, 3D ACIS Polyhedral 
 * <br><br>
* @param ent
* faceted entity.
* @param apply_to_descendents
* delete facets additionally on ent's descendents?
* @param ao
* acis options.
**/
DECL_FCT outcome api_delete_entity_facets(
		ENTITY *ent,
		logical apply_to_descendents = FALSE,
		AcisOptions* ao = NULL
	);

//					MARKING FACETED FACES
//
// Faceted faces can be marked if the user calls the set mark faceted faces.
// Calling this api affects all following faceting operations.
// The default setting is not to mark faceted faces. The user can check if a
// face is marked or not through calling api_faceted_face, see below.

/**
* @nodoc
* Marks faceted faces so that an application may skip re-faceting them later.
* <br><br>
* <b>Role:</b> When this API is called with a <tt>TRUE</tt> argument all subsequent
* faceting operations will mark faceted faces with a mark showing that the face has
* been faceted. That is done by attaching an attribute to the faceted face.
* That attribute is lost when the face is engaged in a merging, splitting, or
* transformation operation.
* <br>
* A call to this function affects all subsequent faceting operations. To ignore
* marking after initiating it, this API function must be called with <tt>FALSE</tt>
* argument.
* <br><br>
* <b>Effect:</b> Changes model
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param mark
* flag to add or ignore marks.
* @param ao
* acis options.
**/
DECL_FCT outcome api_mark_faceted_faces(
		logical mark,
		AcisOptions* ao = NULL
	);



//                           VERTEX_TEMPLATE
//
// The data that is to be stored at a vertex within a facetted representation
// is specified via a VERTEX_TEMPLATE.  The minimum amount of data to be saved
// is the SPAposition.  The following may also be stored: normals and surface
// (u,v) co-ordinates, uv-derivatives and magnitude of uv-derivatives.  In the
// absence of a defining VERTEX_TEMPLATE only SPAposition and normal information
// will be stored.

/**
* @nodoc
* This API creates a vertex template.
* <br><br>
* <b>Role:</b> Valid token types (defined in the <tt>nodedata.hxx</tt> file) and their values are:
* <br><br>
* <table width="60%">
* <tr><td>  <tt>POSITION_TOKEN</tt>       </td>        <td> 3D points (always required)  </td></tr>
* <tr><td>  <tt>NORMAL_TOKEN</tt>         </td>        <td> normals                      </td></tr>
* <tr><td>  <tt>COLOR_TOKEN*</tt>         </td>        <td> vertex-color                 </td></tr>
* <tr><td>  <tt>TRANSPARENCY_TOKEN*</tt>  </td>        <td> degree of transparency at a vertex </td></tr>
* <tr><td>  <tt>TEXTURE_COORDS_TOKEN*</tt></td>        <td> <i>s,t</i> coordinates </td></tr>
* <tr><td>  <tt>UV_TOKEN</tt>             </td>        <td> surface parametric coordinates </td></tr>
* <tr><td>  <tt>UV_DERIVS_TOKEN</tt>      </td>        <td> surface parametric derivatives </td></tr>
* <tr><td>  <tt>UV_CHANGE_TOKEN</tt>      </td>        <td> magnitudes of uv derivatives </td></tr>
* </table>
* <br>
* An asterisk, <tt>*</tt>, means tokens cannot be generated by the faceter and should be
* added by the application.
* <br><br>
* The use count of the returned vertex template is also incremented.
* Functions calling this API function will typically need to call the <tt>remove</tt> method of the
* returned vertex template to decrement its use count when it is no longer needed by the calling function.
* <br><br>
* <b>Effect:</b> Changes model
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param n_tokens
* number of tokens.
* @param tokens
* list of tokens.
* @param tplate
* new vertex template returned.
* @param ao
* acis options.
**/
DECL_FCT outcome api_create_vertex_template(
		int             n_tokens,				// number of tokens in array
		int             tokens[],				// array of tokens
		VERTEX_TEMPLATE *&tplate,				// new vertex template created
		AcisOptions* ao = NULL
	);


/**
* @nodoc
* Modifies a vertex template. The valid token types are:
* <br><br>
* <table width="60%">
* <tr><td> <tt>POSITION_TOKEN (0)</tt> </td>            <td> = 3D points (always required) </td></tr>
* <tr><td> <tt>NORMAL_TOKEN (1)</tt>   </td>            <td> = normals                     </td></tr>
* <tr><td> <tt>COLOR_TOKEN (2*)</tt>   </td>            <td> = vertex color                </td></tr>
* </table>
* <br>
* <b>Errors:</b> Pointer to vertex template must be non-<tt>NULL</tt> and to a <tt>VERTEX_TEMPLATE</tt>.
* <br><br>
* <b>Effect:</b> Changes model
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param n_tokens
* number of tokens in the array.
* @param tokens
* array of tokens.
* @param tplate
* vertex template modified.
* @param ao
* acis options.
**/
DECL_FCT outcome api_modify_vertex_template(
		int             n_tokens,				// number of tokens in array
		int             tokens[],				// array of tokens
		VERTEX_TEMPLATE *tplate,				// vertex template to modify
		AcisOptions* ao = NULL
	);


// Set the VERTEX_TEMPLATE for an entity.  These are applied in a similar way
// to REFINEMENTS.

/**
* @nodoc
* Gets the vertex template attached to the entity.
* <br><br>
* <b>Role:</b> Gets the vertex template attached to the entity. If not found, a <tt>NULL</tt> 
* value is returned.
* <br><br>
* The use count of the returned vertex template is incremented. Functions calling this API function 
* will typically need to call the <tt>remove</tt> method of the returned vertex template to decrement its use count
* when it is no longer needed by the calling function.
* <br><br>
* <b>Errors:</b> Pointer to given entity must be non-<tt>NULL</tt> and to a <tt>BODY</tt>, 
* <tt>LUMP</tt>, <tt>SHELL</tt>, or <tt>FACE</tt>.
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param entity
* entity to examine.
* @param vt
* vertex template returned.
* @param ao
* acis options.
* @see api_get_entity_vertex_template, api_set_entity_vertex_template
**/
DECL_FCT outcome api_get_entity_vertex_template( 
				ENTITY * ent,  
				VERTEX_TEMPLATE *& vt, 
				AcisOptions * ao = NULL);

/**
* @nodoc
* Sets the vertex template on an entity, and optionally its lower topology.
* <br><br>
* <b>Role:</b> This API attaches a vertex template to an entity and (if
* <tt>apply_to_descend</tt> is <tt>TRUE</tt>) all of its descendents (possibly lumps, shells, and
* faces). If the vertex template is <tt>NULL</tt>, all the vertex templates are removed from the
* entity and (if <tt>apply_to_descend</tt> is <tt>TRUE</tt>) all of its descendents.
* <br><br>
* The use count of the given vertex template is incremented when it is attached to an entity. If another
* vertex template is attached to an entity, its use count will be decremented when it is detached.
* <br><br>
* <b>Errors:</b> Pointer to given entity must be non-<tt>NULL</tt> and to a <tt>BODY</tt>, 
* <tt>LUMP</tt>, <tt>SHELL</tt>, or <tt>FACE</tt>. Pointer to given vertex template, if
* non-<tt>NULL</tt>, must be a <tt>VERTEX_TEMPLATE</tt>.
* <br><br>
* <b>Effect:</b> Changes model
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param entity
* entity to examine.
* @param vt
* vertex template to set.
* @param apply_to_descendents
* attach the vertex template additionally to the entity's descendents?
* @param ao
* acis options.
* @see api_get_entity_vertex_template, api_set_entity_vertex_template
**/
DECL_FCT outcome api_set_entity_vertex_template( 
				ENTITY * ent,  
				VERTEX_TEMPLATE * vt, 
				logical apply_to_descendents,
				AcisOptions * ao = NULL);

/**
* @nodoc
* Sets the default vertex template in the faceter. If the vertex
* template is <tt>NULL</tt>, it will use the default settings in the faceter.
* <br><br>
* The use count of the given vertex template is incremented when it is made the default. If another
* default vertex template exists, its use count will be decremented.
* <br><br>
* <b>Errors:</b> Pointer to vertex template, if non-<tt>NULL</tt>, must be a <tt>VERTEX_TEMPLATE</tt>.
* <br><br>
* <b>Effect:</b> Changes model
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param tplate
* default vertex template.
* @param ao
* acis options.
**/
DECL_FCT outcome api_set_default_vertex_template(
		VERTEX_TEMPLATE *tplate,			// vertex template to use
		AcisOptions* ao = NULL
		);

/**
* @nodoc
* Gets the default vertex template. If none exists, a <tt>NULL</tt> value is
* returned.
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param tplate
* default vertex template returned.
* @param ao
* acis options.
**/
DECL_FCT outcome api_get_default_vertex_template(
		VERTEX_TEMPLATE *&tplate,				// vertex template found
		AcisOptions* ao = NULL
		);


//                               FACETS
//
// Facets are generated for an entity taking into account the REFINEMENT and
// VERTEX_TEMPLATE affecting the it.  If the entity is not a BODY the b-rep
// structure is traversed to find the owning BODY and the transform is applied
// when the facets are output to the POLYGON_POINT_MESH.  Any facets generated
// are attached to the face that they represent.

// Query whether or not a face has some facets attached.

/**
* @nodoc
* Determines if a face has been faceted or not.
* <br><br>
* <b>Role:</b> The face is checked to see if a mesh has been attached as an
* attribute. Thus, if the mesh manager does not store its polygons as a mesh on
* the face, this function will always return a negative answer.
* <br><br>
* <b>Errors:</b> Pointer to face is <tt>NULL</tt> or not to a <tt>FACE</tt>.
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param face
* face to be examined.
* @param faceted
* returns <tt>TRUE</tt> if the face has been faceted.
* @param ao
* acis options.
**/
DECL_FCT outcome api_faceted_face(
		FACE    *face,							// face to examine
		logical &faceted,						// TRUE: facets found
		AcisOptions* ao = NULL
		);



// Get a copy of the facets that are attached to an entity.  If no facets
// exist an empty mesh is returned.  The edges are always shared so the
// share_edge_vertices flag is unnecessary.
/**
* @nodoc
* Obsolete: used only in pre-1-7 Faceting.
* <br><br>
* <b>Role:</b> This API gets the facets from all faceted faces within a body
* and return them as a single <tt>POLYGON_POINT_MESH</tt>. The faceted faces must have the
* same vertex template.
* <br><br>
* <b>Errors:</b> Pointer to body is <tt>NULL</tt> or not to a <tt>BODY</tt>.
* Inconsistent vertex templates.
* <br><br>
* <b>Limitations:</b> Pre-1.7 compatibility only.
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param body
* body to examine.
* @param pmesh
* returns mesh collected.
* @param share_edge_vertices
* returns share vertices.
* @param ao
* acis options.
**/

DECL_FCT outcome api_get_body_facets(
		BODY               *body,						// body to examine
		POLYGON_POINT_MESH *&pmesh,						// PPM found
		logical            share_edge_vertices = TRUE,	// IGNORED
		AcisOptions* ao = NULL
		);

/**
* @nodoc
* Obsolete: used only in pre-1-7 Faceting.
* <br><br>
* <b>Role:</b> This API gets the facets from all faceted faces within a lump
* and returns them as a single <tt>POLYGON_POINT_MESH</tt>. The faceted faces must have the
* same vertex template.
* <br><br>
* <b>Errors:</b> Pointer to lump is <tt>NULL</tt> or not to a <tt>LUMP</tt>.
* Inconsistent vertex templates.
* <br><br>
* <b>Limitations:</b> Pre-1.7 compatibility only.
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param lump
* lump to examine.
* @param pmesh
* mesh collected.
* @param share_edge_vertices
* share edge vertices returned.
* @param ao
* acis options.
**/
DECL_FCT outcome api_get_lump_facets(
		LUMP               *lump,						// lump to examine
		POLYGON_POINT_MESH *&pmesh,						// PPM found
		logical            share_edge_vertices = TRUE,	// IGNORED
		AcisOptions* ao = NULL
		);

/**
* Obsolete: used only in pre-1-7 Faceting.
* <br><br>
* <b>Role:</b> This API gets the facets from all faceted faces within a shell
* and returns them as a single <tt>POLYGON_POINT_MESH</tt>. The faceted faces must have the
* same vertex template.
* <br><br>
* <b>Errors:</b> Pointer to shell is <tt>NULL</tt> or not to a <tt>SHELL</tt>. Inconsistent
* vertex templates.
* <br><br>
* <b>Limitations:</b> Pre-1.7 compatibility only.
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param shell
* shell to examine.
* @param pmesh
* mesh collected.
* @param share_edge_vertices
* share edge vertices returned.
* @param ao
* acis options.
**/
DECL_FCT outcome api_get_shell_facets(
		SHELL              *shell,						// shell to examine
		POLYGON_POINT_MESH *&pmesh,						// PPM found
		logical            share_edge_vertices = TRUE,	// IGNORED
		AcisOptions* ao = NULL
		);

/**
* @nodoc
* Obsolete: used only in pre-1-7 Faceting.
* <br><br>
* <b>Role:</b> This API makes a copy of the facets from a face and returns them
* as a <tt>POLYGON_POINT_MESH</tt>. If the face does not have facets attached, the mesh is
* empty.
* <br><br>
* <b>Errors:</b> Pointer to face is <tt>NULL</tt> or not to a <tt>FACE</tt>.
* <br><br>
* <b>Limitations:</b> Pre-1.7 compatibility only.
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param face
* face to examine.
* @param pmesh
* mesh collected.
* @param share_edge_vertices
* share edge vertices returned.
* @param ao
* acis options.
**/
DECL_FCT outcome api_get_face_facets(
		FACE               *face,						// face to examine
		POLYGON_POINT_MESH *&pmesh,						// PPM found
		logical            share_edge_vertices = TRUE,	// IGNORED
		AcisOptions* ao = NULL
		);

/**
* Gets the indexed mesh attached to the entity.
* <br><br>
* <b>Role:</b> If an indexed mesh is not attached to the entity, a <tt>NULL</tt> value is returned.
* <br><br>
* <b>Errors:</b> Pointer to entity is <tt>NULL</tt> or not to a <tt>BODY</tt>, <tt>LUMP</tt>, <tt>SHELL</tt>, or <tt>FACE</tt>.
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param entity
* entity to examine.
* @param mesh
* indexed mesh found.
* @param ao
* acis options.
**/
DECL_FCT outcome api_get_indexed_mesh(
		ENTITY       *entity,					// entity/face to examine
		INDEXED_MESH *&mesh,					// INDEXED_MESH  found
		AcisOptions* ao = NULL
		);


/**
* Gets facet points of the given edge generated by the faceter.
* <br><br>
* <b>Role:</b> This API gets the facet points of the edge, if they have been generated by
* the faceter. If the corresponding faces/edges have not been faceted, then it returns a <tt>NULL</tt>
* <tt>polyline</tt> array pointer. If the edge has an owning body with a transform, that transform is applied
* to the returned SPApositions.
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param edge
* edge entity.
* @param polyline
* array of positions.
* @param num_pts
* number of elements in array.
* @param ao
* acis options.
**/
DECL_FCT outcome api_get_facet_edge_points (  
		EDGE* edge, 
		SPAposition *& polyline, 
		int & num_pts, 
		AcisOptions* ao = NULL
		);

/**
 * @nodoc
 */


DECL_FCT outcome api_set_auto_clipping(
	SPAbox
	);

/**
* @nodoc
* Fires a %ray through a body and returns the hits.
* <br><br>
* <b>Role:</b> <tt>ray_pos</tt> defines the start point of the %ray, and <tt>ray_dir</tt> defines
* the direction of the %ray.
* <br><br>
* The number of hits (the intersections between the %ray and a face) is retuned in <tt>in_count</tt>. 
* For each %hit, the API returns the face intersected in <tt>in_faces</tt>, the position of the %hit 
* in <tt>in_hits</tt>, and the distance along the %ray of the %hit in <tt>in_params</tt>.
* <br><br>
* The body must be faceted prior to calling this function.
* <br><br>
* The results of this function are accurate only to within the facet tolerance. If
* more accurate results are needed @href api_raytest_body or @href api_raytest_ents should be
* used; these two functions may also be faster for analytic surfaces.
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param ray_pos
* %ray start point.
* @param ray_dir
* %ray direction.
* @param in_body
* target body.
* @param in_count
* number of hits.
* @param in_faces
* entities %hit; default is none.
* @param in_hits
* positions %hit; default is none.
* @param in_params
* %ray parameters of the %hit.
* @param ao
* acis options.
**/
DECL_FCT outcome api_fast_find_face(
			SPAposition const &ray_pos,						// ray_point
			SPAunit_vector const &ray_dir,					// ray_direction
			BODY *in_body,									// target body
			int &in_count,									// the number of hits
			ENTITY   ***in_faces = nullptr,					// entities_hit
			SPAposition *&in_hits = SpaAcis::NullObj::get_position_ptr(),	// positions hit
			double   *&in_params = SpaAcis::NullObj::get_double_ptr(),		// ray parameters of the hits
			AcisOptions* ao = NULL
		);

/**
* @nodoc
* Fires a %ray through a body and returns the hits.
* <br><br>
* <b>Role:</b> <tt>ray_pos</tt> defines the start point of the %ray, and <tt>ray_dir</tt> defines
* the direction of the %ray.
* <br><br>
* The number of hits (the intersections between the %ray and a face) is retuned in <tt>in_count</tt>. 
* For each %hit, the API returns the face intersected in <tt>in_faces</tt>, the position of the %hit 
* in <tt>in_hits</tt>, and the distance along the %ray of the %hit in <tt>in_params</tt>.
* <br><br>
* The body must be faceted prior to calling this function.
* <br><br>
* The results of this function are accurate only to within the facet tolerance. If
* more accurate results are needed @href api_raytest_body or @href api_raytest_ents should be
* used; these two functions may also be faster for analytic surfaces.
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param ray_pos
* %ray start point.
* @param ray_dir
* %ray direction.
* @param in_body
* target body.
* @param in_count
* number of hits.
* @param in_faces
* entities %hit; default is none.
* @param in_hits
* positions %hit; default is none.
* @param in_params
* %ray parameters of the %hit.
* @param ao
* acis options.
**/
[[deprecated("Deprecated Interface for \"api_fast_find_face\"; it will be removed in upcoming Release 2025 1.0.0")]]
DECL_FCT outcome api_fast_find_face(
			SPAposition const &ray_pos,						// ray_point
			SPAunit_vector const &ray_dir,					// ray_direction
			BODY *in_body,									// target body
			int &in_count,									// the number of hits
			ENTITY   **&in_faces = *(ENTITY ***)NULL_REF,		// entities_hit
			SPAposition *&in_hits = SpaAcis::NullObj::get_position_ptr(),	// positions hit
			double   *&in_params = SpaAcis::NullObj::get_double_ptr(),		// ray parameters of the hits
			AcisOptions* ao = NULL
		);

/**
* Returns the area of the facets of entity.
* <br><br>
* <b>Role:</b> Gets the area of the facets currently attached to the entity.
* The entity must be already faceted for this function to be effective. Any parts
* of the entity not faceted will be ignored.
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler, 3D ACIS Polyhedral 
 * <br><br>
* @param entity
* Entity for which area needs to be calculated.
* @param area
* Area of the entity.
* @param ao
* acis options.
**/
DECL_FCT outcome api_facet_area(
		ENTITY* entity,	// INPUT: the entity we want the area of
		double& area,	// OUTPUT: the area of the entity
		AcisOptions* ao = NULL	// INPUT: acis options
	);

/**
* Returns facets that approximate a curve.
* <br><br>
* <b>Role:</b> This API computes a list of points and parameter values that
* approximate the given curve to within one or more specified tolerances.
* At least one of the three <tt>in_max_</tt> arguments must be non-zero.
* All three may be non-zero, in which case all three tolerances will be met.
* The returned <tt>outcome</tt> will be okay if any points are returned.
* System warnings are issued if input array sizes are too small or tolerances cannot be met.
* <br><br>
* This API function is not part of the ACIS Faceter. It is utilizes different functionality. 
* This API function is used primarily with edges that are not faceted by the ACIS Faceter.
* Edges that bound faces that are faceted by the Faceter will be faceted when the faces are 
* faceted. The facet points on these edges can be obtained using @href api_get_facet_edge_points. 
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
* <br><br>
* @param in_curve
* Input curve to approximate with linear facets
* @param in_start_param
* Input argument. Starting parameter of <tt>in_curve</tt>.
* @param in_end_param
* Input argument. Ending parameter of <tt>in_curve</tt>. If less than <tt>in_start_param</tt>
* the two are reversed.
* @param in_max_tol
* Input argument. The desired maximum distance between the approximating facets
* and the real curve. If zero, this is ignored and <tt>in_max_length</tt> and/or <tt>in_max_angle</tt>
* is used. If non-zero, should be greater than <tt>SPAresabs</tt>.
* @param in_max_length
* Input argument. The desired maximum length of each facet (the max distance
* between facet points). If zero, this is ignored and <tt>in_max_tol</tt> and/or <tt>in_max_angle</tt>
* is used. If non-zero, should be greater than <tt>SPAresabs</tt>.
* @param in_max_angle
* Input argument. The desired maximum angle, in degrees, between the tangents of
* the two endpoints of any facet. If zero, this is ignored and <tt>in_max_tol</tt> and/or
* <tt>in_max_length</tt> is used. 
* To be considered non-zero, should be greater than 1.
* @param in_max_count
* Input argument. Max number of points and parameters to generate (the size of the <tt>io_points</tt> array).
* If <tt>io_points</tt> or <tt>io_params</tt> are non-zero, must be &lt;= size of smallest non-zero array.
* Otherwise it is ignored.
* @param out_count
* Output argument. Number of points needed to meet tolerances.
* May be greater than <tt>in_max_count</tt>.
* @param io_points
* On input, a preallocated array or zero. On output, facet points on curve.
* If zero, no points will be generated (assuming the caller wants just t-values).
* If pointing to zero, this API will allocate space to contain exactly <tt>out_count</tt> facet points.
* If pointing to non-zero, this API will assume that the array is big enough to contain
* <tt>in_max_count</tt> facet points. If this space is not enough (less than <tt>out_count</tt>),
* then only the first <tt>in_max_count</tt> points are returned.
* It is the responsibility of the user to free this memory using <tt>ACIS_DELETE []</tt>.
* @param io_params
* On input, a pre-allocated array or zero. On output, parameters (t-values) of facet points on curve.
* If zero, no points will be generated (assuming the caller wants just 3D points).
* If pointing to zero, this API will allocate space to contain exactly <tt>out_count</tt> parameters.
* If pointing to non-zero, this API will assume that the array is big enough to contain
* <tt>in_max_count</tt> parameters. If this space is not enough (less than <tt>out_count</tt>),
* then only the first <tt>in_max_count</tt> parameters are returned.
* It is the responsibility of the user to free this memory using <tt>ACIS_DELETE [] STD_CAST</tt>.
* @param ao
* Input argument. Set to version 12 for old behavior.
**/
DECL_FCT outcome api_facet_curve(
		const curve&	in_curve,		// curve to approximate with linear facets
		const double	in_start_param,	// starting parameter
		const double	in_end_param,	// ending parameter
		const double	in_max_tol,		// max tolerance between real curve and facet
		const double	in_max_length,	// max length of facet
		const double	in_max_angle,	// max tangental angle facet passes thru
		const int		in_max_count,	// max number of points to generate
		int&			out_count,		// number of points generated
		SPAposition**	io_points,		// points on curve
		double**		io_params,		// parameter values on curve
		AcisOptions*	ao = NULL);		// version==12 for old behavior

/**
* Returns facets that approximate a curve.
* <br><br>
* <b>Role:</b> This API computes a list of points and parameter values that
* approximate the given curve to within one or more specified tolerances.
* At least one of the three <tt>in_max_</tt> arguments must be non-zero.
* All three may be non-zero, in which case all three tolerances will be met.
* The returned <tt>outcome</tt> will be okay if any points are returned.
* System warnings are issued if input array sizes are too small or tolerances cannot be met.
* <br><br>
* This API function is not part of the ACIS Faceter. It is utilizes different functionality. 
* This API function is used primarily with edges that are not faceted by the ACIS Faceter.
* Edges that bound faces that are faceted by the Faceter will be faceted when the faces are 
* faceted. The facet points on these edges can be obtained using @href api_get_facet_edge_points. 
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
* <br><br>
* @param in_curve
* Input curve to approximate with linear facets
* @param in_start_param
* Input argument. Starting parameter of <tt>in_curve</tt>.
* @param in_end_param
* Input argument. Ending parameter of <tt>in_curve</tt>. If less than <tt>in_start_param</tt>
* the two are reversed.
* @param in_max_tol
* Input argument. The desired maximum distance between the approximating facets
* and the real curve. If zero, this is ignored and <tt>in_max_length</tt> and/or <tt>in_max_angle</tt>
* is used. If non-zero, should be greater than <tt>SPAresabs</tt>.
* @param in_max_length
* Input argument. The desired maximum length of each facet (the max distance
* between facet points). If zero, this is ignored and <tt>in_max_tol</tt> and/or <tt>in_max_angle</tt>
* is used. If non-zero, should be greater than <tt>SPAresabs</tt>.
* @param in_max_angle
* Input argument. The desired maximum angle, in degrees, between the tangents of
* the two endpoints of any facet. If zero, this is ignored and <tt>in_max_tol</tt> and/or
* <tt>in_max_length</tt> is used. 
* To be considered non-zero, should be greater than 1.
* @param out_count
* Output argument. Number of points needed to meet tolerances.
* @param out_points
* Output argument. Linked list of facets. This points to the first point of the
* generated facets. This is a circular double linked list, so one can get to the
* end of the list using <tt>AF_POINT::next(REVERSE)</tt>, and then traverse the list
* backwards, if needed. It is the responsibility of the user to free memory
* used by this linked list at the appropriate time using @href api_delete_all_AF_POINTs().
* @param ao
* Input argument. Set to version 12 for old behavior.
**/
DECL_FCT outcome api_facet_curve(
		const curve&	in_curve,		// curve to approximate with linear polygons
		const double	in_start_param,	// starting parameter
		const double	in_end_param,	// ending parameter
		const double	in_max_tol,		// max tolerance between real curve and facet
		const double	in_max_length,	// max length of facet
		const double	in_max_angle,	// max tangental angle facet passes thru
		int&			out_count,		// number of points generated
		AF_POINT*&		out_points,		// linked list of facets
		AcisOptions*	ao = NULL);		// version==12 for old behavior 

/**
* Returns facets that approximate an edge.
* <br><br>
* <b>Role:</b> This API computes a list of points and parameter values that
* approximate the given edge to within one or more specified tolerances.
* At least one of the three <tt>in_max_</tt> arguments must be non-zero.
* All three may be non-zero, in which case all three tolerances will be met.
* The returned <tt>outcome</tt> will be okay if any points are returned.
* System warnings are issued if input array sizes are too small or tolerances cannot be met.
* <br><br>
* This API function is not part of the ACIS Faceter. It is utilizes different functionality. 
* This API function is used primarily with edges that are not faceted by the ACIS Faceter.
* Edges that bound faces that are faceted by the Faceter will be faceted when the faces are 
* faceted. The facet points on these edges can be obtained using @href api_get_facet_edge_points. 
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
* <br><br>
* @param in_EDGE
* Input EDGE to approximate with linear facets
* @param in_max_tol
* Input argument. The desired maximum distance between the approximating facets
* and the real curve. If zero, this is ignored and <tt>in_max_length</tt> and/or <tt>in_max_angle</tt>
* is used. If non-zero, should be greater than <tt>SPAresabs</tt>.
* @param in_max_length
* Input argument. The desired maximum length of each facet (the max distance
* between facet points). If zero, this is ignored and <tt>in_max_tol</tt> and/or <tt>in_max_angle</tt>
* is used. If non-zero, should be greater than <tt>SPAresabs</tt>.
* @param in_max_angle
* Input argument. The desired maximum angle, in degrees, between the tangents of
* the two endpoints of any facet. If zero, this is ignored and <tt>in_max_tol</tt> and/or
* <tt>in_max_length</tt> is used. 
* To be considered non-zero, should be greater than 1.
* @param in_max_count
* Input argument. Max number of points and parameters to generate (the size of the <tt>io_points</tt> array).
* If <tt>io_points</tt> or <tt>io_params</tt> are non-zero, must be &lt;= size of smallest non-zero array.
* Otherwise it is ignored.
* @param out_count
* Output argument. Number of points needed to meet tolerances.
* May be greater than <tt>in_max_count</tt>.
* @param io_points
* On input, a pre-allocated array or zero. On output, facet points on the edge.
* If zero, no points will be generated (assuming the caller wants just t-values).
* If pointing to zero, this API will allocate space to contain exactly <tt>out_count</tt> facet points.
* If pointing to non-zero, this API will assume that the array is big enough to contain
* <tt>in_max_count</tt>facet points. If this space is not enough (less than <tt>out_count</tt>),
* then only the first <tt>in_max_count</tt>points are returned.
* It is the responsibility of the user to free this memory using <tt>ACIS_DELETE []</tt>.
* @param io_params
* On input, a preallocated array or zero. On output, parameters (t-values) of facet points on the edge.
* If zero, no points will be generated (assuming the caller wants just 3D points).
* If pointing to zero, this API will allocate space to contain exactly <tt>out_count</tt> parameters.
* If pointing to non-zero, this API will assume that the array is big enough to contain
* <tt>in_max_count</tt>parameters. If this space is not enough (less than <tt>out_count</tt>),
* then only the first <tt>in_max_count</tt>parameters are returned.
* It is the responsibility of the user to free this memory using <tt>ACIS_DELETE [] STD_CAST</tt>.
* @param ao
* Input argument. Set to version 12 for old behavior.
**/
DECL_FCT outcome api_facet_edge(
		const EDGE*		in_EDGE,		// EDGE to approximate with linear polygons
		const double	in_max_tol,		// max tolerance between real curve and facet
		const double	in_max_length,	// max length of facet
		const double	in_max_angle,	// max tangental angle facet passes thru
		const int		in_max_count,	// max number of points to generate
		int&			out_count,		// number of points generated
		SPAposition**	io_points,		// points on curve
		double**		io_params,		// parameter values on curve
		AcisOptions*	ao = NULL);		// version==12 for old behavior

/**
* Returns facets that approximate an edge.
* <br><br>
* <b>Role:</b> This API computes a list of points and parameter values that
* approximate the given edge to within one or more specified tolerances.
* At least one of the three <tt>in_max_</tt> arguments must be non-zero.
* All three may be non-zero, in which case all three tolerances will be met.
* The returned <tt>outcome</tt> will be okay if any points are returned.
* System warnings are issued if input array sizes are too small or tolerances cannot be met.
* <br><br>
* This API function is not part of the ACIS Faceter. It is utilizes different functionality. 
* This API function is used primarily with edges that are not faceted by the ACIS Faceter.
* Edges that bound faces that are faceted by the Faceter will be faceted when the faces are 
* faceted. The facet points on these edges can be obtained using @href api_get_facet_edge_points. 
* <br><br>
* <b>Effect:</b> Read-only
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
* <br><br>
* @param in_EDGE
* Input EDGE to approximate with linear facets
* @param in_max_tol
* Input argument. The desired maximum distance between the approximating facets
* and the real curve. If zero, this is ignored and <tt>in_max_length</tt> and/or <tt>in_max_angle</tt>
* is used. If non-zero, should be greater than <tt>SPAresabs</tt>.
* @param in_max_length
* Input argument. The desired maximum length of each facet (the max distance
* between facet points). If zero, this is ignored and <tt>in_max_tol</tt> and/or <tt>in_max_angle</tt>
* is used. If non-zero, should be greater than <tt>SPAresabs</tt>.
* @param in_max_angle
* Input argument. The desired maximum angle, in degrees, between the tangents of
* the two endpoints of any facet. If zero, this is ignored and <tt>in_max_tol</tt> and/or
* <tt>in_max_length</tt> is used. 
* To be considered non-zero, should be greater than 1.
* @param out_count
* Output argument. Number of points needed to meet tolerances.
* @param out_points
* Output argument. Linked list of facets. This points to the first point of the
* generated facets. This is a circular double linked list, so one can get to the
* end of the list using <tt>AF_POINT::next(REVERSE)</tt>, and then traverse the list
* backwards, if needed. It is the responsibility of the user to free memory
* used by this linked list at the appropriate time using @href api_delete_all_AF_POINTs().
* @param ao
* Input argument. Set to version 12 for old behavior.
**/
DECL_FCT outcome api_facet_edge(
		const EDGE*		in_EDGE,		// EDGE to approximate with linear polygons
		const double	in_max_tol,		// max tolerance between real curve and facet
		const double	in_max_length,	// max length of facet
		const double	in_max_angle,	// max tangental angle facet passes thru
		int&			out_count,		// number of points generated
		AF_POINT*&		out_points,		// linked list of facets
		AcisOptions*	ao = NULL);		// version==12 for old behavior

/**
* Delete the linked list of AF_POINTs.
* <br><br>
* <b>Role:</b> Free up memory used by the linked list.
* <br><br>
* <b>Effect:</b>
* <br><br>
* <b>Journal: </b> Not Available
* <br><br>
* <b>Product(s):</b> 3D Viz Exchange, 3D ACIS Modeler 
 * <br><br>
* @param first_point
* Any point in the circular double linked list.
* @param ao
* acis options.
**/
DECL_FCT outcome api_delete_all_AF_POINTs(
		AF_POINT* first_point,
		AcisOptions*	ao = NULL);
/** @} */

/**
* This option header provides a global switch to turn multithreaded faceting on/off.
**/
DECL_FCT extern option_header faceter_allow_multithreading;

/**
* Sets the mesh manager to the ACIS default mesh manager which
* puts an INDEXED_MESH on each face.  
**/
DECL_FCT outcome api_set_mesh_manager_to_default();

// expert use only.  expects all params to be within the part of the curve corresponding to the edge.
// (i.e., take edge param range, if edge is reversed, reverse the interval, all params must be taken from here.)
// Faceter results can be bad if bad edge facets are provided, so don't use this unless you have a very good reason.
/**
* @nodoc.
**/
DECL_FCT outcome make_af_points_from_param_list( int num_params, double const* params, EDGE* edge );

#endif // FACETER_API_HEADER
