/* ORIGINAL: acis2.1/kernutil/d3_fn2/cnc.hxx */
/* $Id: cnc.hxx,v 1.11 2002/08/09 17:15:29 jeff Exp $ */
/*******************************************************************/
/*    Copyright (c) 1989-2020 by Spatial Corp.                     */
/*    All rights reserved.                                         */
/*    Protected by U.S. Patents 5,257,205; 5,351,196; 6,369,815;   */
/*                              5,982,378; 6,462,738; 6,941,251    */
/*    Protected by European Patents 0503642; 69220263.3            */
/*    Protected by Hong Kong Patent 1008101A                       */
/*******************************************************************/

#ifndef CNCH
#define CNCH

#include "dcl_kern.h"
#include "res.hxx"
#include "math.hxx"
#include "param.hxx"

#if defined D3_STANDALONE || defined D3_DEBUG

class PS_FILE;
class D3_ostream;
class D3_istream;
class CONIC;

DECL_KERN D3_ostream& 	operator<<( D3_ostream&, CONIC& );
DECL_KERN D3_istream& 	operator>>( D3_istream&, CONIC& );

#ifdef D3_DEBUG
PS_FILE& 	operator<<( PS_FILE&, CONIC& );
#endif

#endif


// The CONIC class stores a conic section, and presents information about it; 
// e.g. where is its centre, and where is a nearby point on it. The conic is 
// held in a normalised form, i.e. it has no term in xy. This is equivalent to 
// a rotation of the axes for a general conic. The CONIC class always works in 
// the rotated plane, and returns results in this plane; it is left to the 
// application to transform these to the working plane.  
//
// The conic is a*x*x + b*y*y + c*x + d*y + e = 0
//
// The conic is never explicitly classified (as ellipse, hyperbola, etc) 
// although it is done implicitly in some member functions. The main use of 
// the conic is to approximate intersection curves, from a single point. It 
// follows that the conic is only accurate in the neighbourhood of that point, 
// so the policy is to use local information from the conic, in preference to 
// global information such as type. If, however, the expansion point is at the 
// centre of the conic, then it may be important to know whether the conic is 
// closed (ellipse, point or imaginary ellipse) or open (hyperbola, parabola, 
// parallel lines). The CONIC::closed member function is provided for this 
// purpose. 
// 
//

class 	DECL_KERN CONIC : public ACIS_OBJECT
    {
    double 	a,b,c,d,e;	// Conic is a*x*x + b*y*y + c*x + d*y + e = 0

    // Intersect the conic with a line ( ft, gt ) through the current origin. 
    // Return the SPAparameter step from the origin to the intersection. 

    SPApar_vec	intersect_line_with_conic( double, double );


    // These functions are intended to avoid zero divides rather than 
    // to classify the conic. 

    logical	a_zero()	{ return a<SPAresnor && a>-SPAresnor; }
    logical	b_zero()	{ return b<SPAresnor && b>-SPAresnor; }
    logical	c_zero()	{ return c<SPAresnor && c>-SPAresnor; }
    logical	d_zero()	{ return d<SPAresnor && d>-SPAresnor; }
    logical	e_zero()	{ return e<SPAresabs && e>-SPAresabs; }


public:
    // Constructor. a=null indicates an uninitialised conic

    	CONIC()	  : 	a(SPAnull), b(SPAnull), c(SPAnull), d(SPAnull), e(SPAnull) 	{}



    // Write in the conic coefficients. 

    void    overwrite( double aa, double bb, double cc, double dd, double ee )
		{ a=aa; b=bb; c=cc; d=dd; e=ee; }


    // Return TRUE if the conic has not been initialised. 

    logical unset()	{ return a == SPAnull; }


    // Reset a conic to its uninitialised state. 

    void    reset()	{ a=SPAnull; }


    // Return a SPAparameter step calculated to move onto the conic centre.
    //
    // Ellipse, hyperbola 	- return the conic centre
    //
    // Single line, degenerate 	- return SPApar_vec( null, null ) 
    // 
    // Parallel lines 		- return the closest point on the centre line
    // 
    // Parabola 		- return the closest point on the axis 
    //  

    SPApar_vec	centre();


    // Return a SPAparameter step calculated to move onto the conic.
    // The nearpoint is not generally the closest point on the conic, although 
    // it is a first-order approximation to it. 
    // 
    // If the conic is imaginary then the centre is returned. 
    // If it is degenerate, then SPApar_vec( null, null ) is returned. 

    SPApar_vec	nearpoint();	


    // Return a SPAparameter step calculated to move from one side of the conic to
    // the other. The current origin must be on the conic. The far point is 
    // generated by constructing a line normal to the conic, and finding where 
    // it re-intersects the conic. 
    //

    SPApar_vec	farpoint();	


    // Return the principal conic axis at crossing lines. This is the direction 
    // bisecting the smaller angle between the two lines. 

    SPApar_dir	main_axisdir()	
    	{ double b_abs = D3_fabs( b ); 
	  return b_abs > D3_fabs( a ) ? SPApar_dir(1,0) : SPApar_dir(0,1); }


    // Return the nearest point on the axis of the conic. 

    SPApar_vec	x_axispoint();
    SPApar_vec	y_axispoint();
    SPApar_vec	main_axispoint();


    // Return the distance to the axis. If there is the danger of a zero 
    // divide, return 'null' to indicate no solution. 

    double	x_axisdist()		{ return b_zero() ? SPAnull : 0.5*d/b; }
    double	y_axisdist()		{ return a_zero() ? SPAnull : 0.5*c/a; }
    double	main_axisdist()		
    	{ double b_abs = D3_fabs( b ); 
	  return b_abs > D3_fabs( a ) ? x_axisdist() : y_axisdist(); }

    // Return the tangent directions at crossing lines. The convention used 
    // here, and in FUNC_2V::explore, is that when the conic is viewed from 
    // above, the direction of the conic is such that positive values are on 
    // the right. Note that the direction returned by crossing_line_forward_dir 
    // and the opposite direction, are both forward directions. Only one is 
    // returned. The same is true of the backward direction. The function 
    // should only be used when the conic is crossing lines (i.e. a terminator).

    SPApar_vec	crossing_line_forward_dir();
    SPApar_vec	crossing_line_backward_dir();


    // Return the smallest distance that will move from the centre of 
    // crossing lines to a function value of =/- SPAresabs. 
    // Return the corresponding step. 

    double	minimum_flat_extent();
    SPApar_vec	minimum_flat_extent_step();


    // Return TRUE for an ellipse, isolated point or imaginary ellipse, 
    //	      FALSE otherwise

    logical 	closed();

    // Return TRUE for a single line or completely degenerate conic. The 
    // SPAresabs test is not justified here but higher accuracy is not 
    // achievable in practice. 

    logical 	degenerate()	{ return a*a + b*b < 2.0 * SPAresabs * SPAresabs; }


    // Return TRUE for parallel (imaginary or otherwise) or coincident lines

    logical 	parallel()	{ return a_zero() && c_zero()  ||
					 b_zero() && d_zero(); }


    // Return the sign of the leading term. 

    logical	positive()	{ return a>0; }


#if defined D3_STANDALONE || defined D3_DEBUG

    friend DECL_KERN D3_ostream& 	operator<<( D3_ostream&, CONIC& );
    friend DECL_KERN D3_istream& 	operator>>( D3_istream&, CONIC& );

#ifdef D3_DEBUG
    friend PS_FILE& 	operator<<( PS_FILE&, CONIC& );
#endif

#endif
    };


// DEGENERATE_FLAT_EXTENT is used as a default value for the flat extent at a
// degenerate point. It is set in cnc.cxx

extern COMPONENT_CONST double DEGENERATE_FLAT_EXTENT;

#endif
