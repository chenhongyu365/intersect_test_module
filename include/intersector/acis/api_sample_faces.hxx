/*******************************************************************/
/*    Copyright (c) 1989-2020 by Spatial Corp.                     */
/*    All rights reserved.                                         */
/*    Protected by U.S. Patents 5,257,205; 5,351,196; 6,369,815;   */
/*                              5,982,378; 6,462,738; 6,941,251    */
/*    Protected by European Patents 0503642; 69220263.3            */
/*    Protected by Hong Kong Patent 1008101A                       */
/*******************************************************************/
#ifndef api_sample_faces_hxx
#define api_sample_faces_hxx

class sample_faces_results_impl;
class sample_faces_options_impl;
class FACE;
class EDGE;
class SPAposition_vector;

#include "mmgr.hxx"
#include "api.hxx"
#include "dcl_hlc.h"

/**
 * @file api_sample_faces.hxx
 * @CAA2Level L1
 * @CAA2Usage U1
 * \addtogroup ACISQUERIES
 *
 * @{
 */


/**
* Class <tt>sample_faces_results</tt> is the container for holding
* the sample points obtained from <tt>api_sample_faces</tt>
**/
class DECL_HLC sample_faces_results : public ACIS_OBJECT
{
	sample_faces_results_impl *m_results;
public:

	/**
	* returns all sample points.
	**/
	void get_sample_points(SPAposition_vector &samples) const;

	/**
	* returns the sample points for the given face.
	**/
	void get_sample_points(const FACE *face, SPAposition_vector &samples) const;

	/**
	* returns the list of faces for which the operation failed if the fail_safe flag was set to true.
	**/
	void get_failed_faces(ENTITY_LIST *failed_faces) const;

	/**
	* @nodoc
	**/
	sample_faces_results();
	/**
	* @nodoc
	**/
	~sample_faces_results();
	/**
	* @nodoc
	**/
	sample_faces_results(const sample_faces_results &);

	/**
	* @nodoc
	**/
	const sample_faces_results& operator=(const sample_faces_results &);

	/**
	* @nodoc. internal use only.
	**/
	sample_faces_results_impl* get_impl();
};

/**
* Class <tt>sample_faces_options</tt> controls the user
* adjustable options for @href api_sample_faces. The main
* adjustable parameters are (1) sample spacing (the sample points
* are no further than the sample space from their nearest neighbors)
* (2) angle tolerance (no sample points should have normals forming
* an angle larger than angle tolerance to their nearest neighbors)
* and (3) edge offset (no sample points should be closer than the specified
* distance from the edge). Other parameters: hug-face-boundaries, sampling-method, sampling-order, fail-safe.
**/
class DECL_HLC sample_faces_options : public ACIS_OBJECT
{
	sample_faces_options_impl *m_impl;
public:
	/**
	* Allows the user to control the offset distance from a given edge. (Custom edge offset)
	**/
	void set_offset_distance(const EDGE *edge, double offset);
	/**
	* Allows the user to control the offset distance from all edges in the input. (Default edge offset)
	**/
	void set_offset_distance(double offset);
	/**
	* Allows the user to control the angle tolerance (given in degrees). Negative or zero value means that the angle tolerance is ignored.
	**/
	void set_angle_tolerance(double angle_tol);
	/**
	* Allows the user to control the sample spacing. Negative or zero value means that a default sample spacing is computed from the bounding box of all input entities.
	**/
	void set_sample_spacing(double spacing);

	/**
	* Returns the offset which is in effect for the given edge
	**/
	double get_offset_distance(const EDGE *edge) const;
	/**
	* Returns the angle tolerance (in degrees).
	**/
	double get_angle_tolerance() const;
	/**
	* Returns the sample spacing.
	**/
	double get_sample_spacing() const;

	/**
	* Sets the value of the <tt>hug_boundaries</tt> flag.  For analytic faces,
	* this API trims a bunch of isolines at the boundaries of the face,
	* then picks evenly spaced points within the face.  If the <tt>hug_boundaries</tt>
	* flag is true, the API makes sure that we have points distributed all along
	* the face boundaries.
	* It only affects faces sampled by the isoline sampling method.
	* Default for this is false.
	**/
	void set_hug_face_boundaries(bool hug_boundaries);

	/**
	* Checks the setting of the <tt>hug_face_boundaries</tt> flag.
	**/
	bool hug_face_boundaries() const;

	/**
	* Available sampling methods:
	* @param isoline_always
	* sample all faces along parameter lines.
	* @param faceter_always
	* sample all faces using the faceter.
	* @param faceter_for_splines_only
	* sample analytic surfaces and surfaces of revolution along parameter lines; sample splines using the faceter
	**/
	enum sampling_method { isoline_always, faceter_always, faceter_for_splines_only };

	/**
	* Sets the sampling method. The isoline method samples a face along parameter lines.
	* The faceter method returns the vertices generated by faceting a face.
	* The default value is <tt>faceter_for_splines_only</tt>, which means that the isoline
	* method is used for faces that are not splines and the faceter method is used for
	* spline faces.
	**/
	void set_sampling_method(sampling_method sm);

	/**
	* Checks the setting of <tt>sampling_method</tt>.
	**/
	sampling_method get_sampling_method() const;

	/**
	* Sampling order values
	* @param lane_on
	* Sample points move back and forth between alternating rows.
	* @param lane_off
	* Sample points move forward in each row on a face.
	**/
	enum sampling_order { lane_on, lane_off };

	/**
	* Sets the order of the sample points in the returned array. Lane off means
	* that sample points move forward in each row on a face, while lane on means that
	* sample points move back and forth between alternating rows.
	* It only affects faces sampled by the isoline sampling method.
	* The default is <tt>lane_off</tt>.
	**/
	void set_sampling_order(sampling_order so);

	/**
	* Checks the setting of <tt>sampling_order</tt>.
	**/
	sampling_order get_sampling_order() const;

	/**
	* Sets the value of the <tt>fail_safe</tt> flag. If it is true,
	* <tt>api_sample_faces</tt> does not return an error if the operation fails for
	* some of the faces. In this case the list of failed faces can be obtained
	* through the class <tt>sample_faces_results</tt>. The default value is false.
	**/
	void set_fail_safe(bool fail_safe);

	/**
	* Checks the setting of the <tt>fail_safe</tt> flag.
	**/
	bool fail_safe() const;

	/**
	* @nodoc.
	**/
	sample_faces_options();
	/**
	* @nodoc.
	**/
	sample_faces_options(const sample_faces_options &);
	/**
	* @nodoc.
	**/
	const sample_faces_options& operator=(const sample_faces_options &);
	/**
	* @nodoc.
	**/
	~sample_faces_options();
	/**
	* @nodoc. internal use only.
	**/
	const sample_faces_options_impl* get_impl() const;
};

/**
* The API <tt>api_sample_faces</tt> calculates sample points on a user specified set of faces.
* For more details, see the Technical Article <i>[Sample Points on Faces](http://doc.spatial.com/articles/s/a/m/Sample_Points_on_Faces_0829.html)</i>
* <br><br>
* <b>Role:</b> This API computes a representative set of sample points on the FACE(s) selected by the user.
* <br><br>
* <b>Effect:</b> Read-only.
* <br><br>
* <b>Journal:</b> Available
* <br><br>
* <b>Product(s):</b> 3D ACIS Modeler
* <br><br>
* @param faces
* List of ENTITYs whose FACEs need to be sampled
* @param sf_results
* Result object that contains the sample points calculated
* @param sfo
* Options object for defining the sampling parameters
* @param ao
* ACIS options for versioning and journaling
**/
DECL_HLC outcome api_sample_faces(const ENTITY_LIST &faces,
								  sample_faces_results &sf_results,
								  const sample_faces_options *sfo = NULL,
								  AcisOptions *ao = NULL);


/** @} */
#endif
